<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VeilaLightâ„¢ - Zero-G Projector Backrest</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f2f5; font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; cursor: move; }
        
        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 240px;
            border: 1px solid rgba(255,255,255,0.8);
            transition: all 0.3s ease;
            z-index: 10;
        }

        h1 { margin: 0 0 5px 0; font-size: 20px; font-weight: 800; color: #111; text-align: center; letter-spacing: 1px; }
        h2 { margin: 0 0 15px 0; font-size: 10px; font-weight: 500; color: #666; text-transform: uppercase; letter-spacing: 2px; }
        
        #clock-container {
            position: relative;
            width: 140px;
            height: 140px;
            margin: 10px 0;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        
        canvas#angle-picker { width: 100%; height: 100%; display: block; }
        .status-text { font-size: 14px; font-weight: bold; color: #2196F3; margin-top: 5px; }
        .highlight { color: #E91E63; font-weight: bold; }
        .controls-tip {
            position: absolute; top: 20px; right: 20px; color: #666; font-size: 12px;
            background: rgba(255,255,255,0.7); padding: 8px 12px; border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        /* æ¨¡å¼åˆ‡æ¢æŒ‰é’®ç»„ */
        .mode-switch {
            margin-top: 15px;
            display: flex;
            background: #eee;
            border-radius: 20px;
            padding: 4px;
            width: 100%;
            gap: 2px;
        }
        .mode-btn {
            flex: 1;
            border: none;
            background: transparent;
            padding: 8px 0;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mode-btn.active {
            background: #fff;
            color: #111;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .mode-btn:hover { color: #111; }

        /* è§†é¢‘æŒ‰é’®æ ·å¼ */
        .video-container { width: 100%; margin-top: 15px; position: relative; }
        .video-btn {
            display: block; width: 100%; padding: 10px 0; background: #222; color: #fff;
            text-align: center; border-radius: 8px; font-size: 12px; font-weight: 600;
            text-decoration: none; transition: background 0.2s; cursor: pointer;
        }
        .video-btn:hover { background: #444; }
        .video-btn::after {
            content: attr(data-tooltip); position: absolute; bottom: 120%; left: 50%;
            transform: translateX(-50%); background: rgba(0,0,0,0.8); color: #fff;
            padding: 6px 10px; border-radius: 6px; font-size: 11px; white-space: nowrap;
            opacity: 0; visibility: hidden; transition: all 0.2s; pointer-events: none;
        }
        .video-btn:hover::after { opacity: 1; visibility: visible; bottom: 130%; }

        /* Tooltip æ ·å¼ */
        #tooltip {
            position: absolute;
            display: none;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            max-width: 220px;
            pointer-events: none;
            z-index: 100;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: opacity 0.1s;
        }
        #tooltip strong {
            display: block;
            color: #4db8ff;
            font-size: 13px;
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 4px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

<div class="controls-tip">
    ğŸ–±ï¸ å·¦é”®å¹³ç§» | å³é”®æ—‹è½¬ | æ»šè½®ç¼©æ”¾
</div>

<div id="ui-panel">
    <h1>VeilaLightâ„¢</h1>
    <h2>Zero-G Projector Backrest</h2>
    
    <div class="mode-switch">
        <button class="mode-btn active" onclick="setMode('xray')">é€è§†</button>
        <button class="mode-btn" onclick="setMode('solid')">æ‹ŸçœŸ</button>
        <button class="mode-btn" onclick="setMode('exploded')" style="color:#E91E63">çˆ†ç‚¸è§†å›¾</button>
    </div>

    <div id="clock-container">
        <canvas id="angle-picker" width="280" height="280"></canvas>
    </div>
    <div class="status-text" id="angle-value">åå§¿ (90Â°)</div>

    <div class="video-container">
        <!-- ç¡®ä¿ä½ çš„ video.mp4 ä¹Ÿåœ¨åŒä¸€ä¸ªæ–‡ä»¶å¤¹é‡Œ -->
        <a href="video.mp4" target="_blank" class="video-btn" data-tooltip="åˆä»£åŸå‹çš„åŸå§‹å½•åƒ">
            Works-like Demo (V0.1)
        </a>
    </div>
</div>

<div id="tooltip"></div>
<div id="canvas-container"></div>

<script>
    // ==========================================
    // 1. åˆå§‹åŒ–åœºæ™¯
    // ==========================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f7fa); 

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(20, 15, 20); 
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; 
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
    orbitControls.enableDamping = true;
    orbitControls.dampingFactor = 0.05;
    orbitControls.minDistance = 2;
    orbitControls.maxDistance = 100;
    
    orbitControls.enablePan = true;
    orbitControls.screenSpacePanning = true;
    orbitControls.mouseButtons = {
        LEFT: THREE.MOUSE.PAN,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.ROTATE
    };

    // ==========================================
    // 2. æè´¨åº“
    // ==========================================
    const matTranslucentBody = new THREE.MeshPhysicalMaterial({ 
        color: 0x2a2a2a, roughness: 0.2, metalness: 0.1, transmission: 0.7, 
        thickness: 1.0, transparent: true, opacity: 0.8, side: THREE.DoubleSide 
    });
    const matTranslucentProj = new THREE.MeshPhysicalMaterial({ 
        color: 0x222222, roughness: 0.2, metalness: 0.5, transmission: 0.8, 
        transparent: true, opacity: 0.8, side: THREE.DoubleSide 
    });
    
    // ã€æ›´æ–°ã€‘å®ç‰©æ‹ŸçœŸæè´¨ - é¢œè‰²å¤åŸä¸ºæ·±ç‚­ç°
    const matSolidBody = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a, 
        roughness: 0.9, 
        metalness: 0.0, 
        side: THREE.DoubleSide 
    });
    
    // ã€æ›´æ–°ã€‘æŠ•å½±å¤–å£³æ‹ŸçœŸæè´¨ - é¢œè‰²å¤åŸä¸ºæ·±ç©ºç°
    const matSolidProj = new THREE.MeshPhysicalMaterial({ 
        color: 0x111111, 
        roughness: 0.4, 
        metalness: 0.2, 
        clearcoat: 0.1, 
        side: THREE.DoubleSide 
    });
    
    // æè´¨åˆå§‹åŒ–è¾…åŠ©å‡½æ•°
    function initMat(mat) { 
        if (mat.emissive) {
            mat.emissive.setHex(0x000000); 
        }
        return mat; 
    }

    const matSkeleton = initMat(new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.9 }));
    const matSkeletonInternal = initMat(new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.9 })); 

    const matInternal = initMat(new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5, metalness: 0.5 }));
    const matPCB = initMat(new THREE.MeshStandardMaterial({ color: 0x004400, roughness: 0.4, metalness: 0.5 }));
    const matChamber = initMat(new THREE.MeshPhysicalMaterial({
        color: 0x88ccff, roughness: 0.2, metalness: 0.1, 
        transmission: 0.3, transparent: true, opacity: 0.6, side: THREE.DoubleSide
    }));
    const matFan = initMat(new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 }));
    const matMetal = initMat(new THREE.MeshPhysicalMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 1.0 }));
    const matBezel = initMat(new THREE.MeshPhysicalMaterial({ color: 0x050505, roughness: 0.2, metalness: 0.9 }));
    
    const matLensSimple = initMat(new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.8 }));
    
    // ã€æ›´æ–°ã€‘æ•£çƒ­å­”æè´¨ï¼šç»Ÿä¸€æ”¹ä¸ºæ·±ç‚­ç° (0x2a2a2a)
    const matVent = new THREE.MeshBasicMaterial({ color: 0x2a2a2a });
    
    const matLine = new THREE.LineDashedMaterial({ color: 0x888888, dashSize: 0.5, gapSize: 0.3, opacity: 0.5, transparent: true });

    // ==========================================
    // 3. æ„å»ºæ¨¡å‹
    // ==========================================
    const root = new THREE.Group();
    root.position.set(9, 1, 0); 
    root.rotation.y = -Math.PI * 1.5; 
    root.scale.set(0.9, 0.9, 0.9);
    scene.add(root);

    const parts = {
        seatShell: null,
        seatSkel: null,
        hinge: null,
        hingeInternal: null,
        backShell: null,
        backSkel: null,
        projShell: null,
        projInternal: null,
        chamberL: null,
        chamberR: null,
        fans: [],
        lines: new THREE.Group(),
        beam: null,
        l1: null, l2: null, l3: null
    };
    scene.add(parts.lines);

    const CONFIG = { width: 8, thickness: 2, radius: 0.6, projLength: 3.5, backLength: 10, seatLength: 5 };
    function createBaseShape() {
        const s = new THREE.Shape(); const r=CONFIG.radius, w=CONFIG.width/2-r, h=CONFIG.thickness/2-r;
        s.moveTo(-w,-h-r); s.lineTo(w,-h-r); s.absarc(w,-h,r,-Math.PI/2,0); s.lineTo(w+r,h); s.absarc(w,h,r,0,Math.PI/2);
        s.lineTo(-w,h+r); s.absarc(-w,h,r,Math.PI/2,Math.PI); s.lineTo(-w-r,-h); s.absarc(-w,-h,r,Math.PI,Math.PI*1.5);
        return s;
    }
    const baseShape = createBaseShape();

    function createGuideline(start, end) {
        const points = [start, end];
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geo, matLine);
        line.computeLineDistances(); line.visible = false; return line;
    }

    // --- A. åå« ---
    const seatGroup = new THREE.Group(); root.add(seatGroup);
    const seatGeo = new THREE.ExtrudeGeometry(baseShape, { depth: CONFIG.seatLength, steps: 20, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 3 });
    const posSeat = seatGeo.attributes.position;
    function getSeatDeformation(x, y, z, length) {
        const t = Math.max(0, z / length); let newY = y;
        if (y > 0) {
            newY *= Math.pow(1 - t * 0.95, 2); newY -= Math.pow(Math.abs(x/(CONFIG.width/2)), 2) * 0.15 * (1-t*0.5);
        } else { newY *= (1 - Math.pow(t, 1.5) * 0.85); }
        return newY;
    }
    for(let i=0; i<posSeat.count; i++) posSeat.setY(i, getSeatDeformation(posSeat.getX(i), posSeat.getY(i), posSeat.getZ(i), CONFIG.seatLength));
    seatGeo.computeVertexNormals();
    parts.seatShell = new THREE.Mesh(seatGeo, matTranslucentBody);
    parts.seatShell.castShadow = true; seatGroup.add(parts.seatShell);

    const skelWidth = CONFIG.width * 0.4, skelHeight = 0.25, skelLen = CONFIG.seatLength * 0.85 * 0.9;
    const seatSkelGeo = new THREE.BoxGeometry(skelWidth, skelHeight, skelLen, 10, 2, 20);
    const posSkel = seatSkelGeo.attributes.position;
    for(let i=0; i<posSkel.count; i++) {
        let x = posSkel.getX(i), y = posSkel.getY(i), z = posSkel.getZ(i) + skelLen / 2, t = Math.max(0, z / CONFIG.seatLength);
        let taper = 1.0 - Math.pow(t, 1.2) * 0.8; y *= taper; x *= (1.0 - t * 0.4);
        let shellBottom = -CONFIG.thickness/2 * (1 - Math.pow(t, 1.5) * 0.85);
        let targetY = 0 * (1-t) + (shellBottom + 0.3) * t; 
        posSkel.setY(i, y + targetY); posSkel.setZ(i, z);
    }
    seatSkelGeo.computeVertexNormals();
    parts.seatSkel = new THREE.Mesh(seatSkelGeo, matSkeleton); // ä½¿ç”¨ç‹¬ç«‹éª¨æ¶æè´¨å®ä¾‹
    seatGroup.add(parts.seatSkel);

    // --- B. è½¬è½´ ---
    const hingeGroup = new THREE.Group(); root.add(hingeGroup);
    parts.hinge = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, CONFIG.width - 0.2, 32).rotateZ(Math.PI/2), matMetal);
    hingeGroup.add(parts.hinge);
    parts.hingeInternal = new THREE.Group();
    // ä½¿ç”¨ç‹¬ç«‹çš„ matSkeleton
    const hd1 = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32).rotateZ(Math.PI/2), matSkeleton); hd1.position.x = -2;
    const hd2 = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32).rotateZ(Math.PI/2), matSkeleton); hd2.position.x = 2;
    parts.hingeInternal.add(hd1, hd2); hingeGroup.add(parts.hingeInternal);

    // --- C. é èƒŒä¸æŠ•å½± ---
    const backGroup = new THREE.Group(); root.add(backGroup);
    const backGeo = new THREE.ExtrudeGeometry(baseShape, { depth: CONFIG.backLength, steps: 40, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 3 });
    const posBack = backGeo.attributes.position;
    for(let i=0; i<posBack.count; i++) {
        let x = posBack.getX(i), y = posBack.getY(i), z = posBack.getZ(i), t = z / CONFIG.backLength;
        if (y > 0) {
            let curve = Math.exp(-Math.pow((t-0.15)*5,2))*0.35 + Math.exp(-Math.pow((t-0.85)*8,2))*0.25 - Math.sin(t*Math.PI)*0.1;
            let sideTaper = - Math.pow(Math.abs(x/(CONFIG.width/2)),4)*0.5;
            let endFade = Math.pow(1 - Math.pow(t, 8), 2); y += (curve + sideTaper) * endFade;
            if (t > 0.95) { let scaleFactor = 1.0 - Math.pow((t-0.95)/0.05, 2) * 0.005; y *= scaleFactor; x *= scaleFactor; }
        }
        if (y <= 0 && t > 0.95) { let scaleFactor = 1.0 - Math.pow((t-0.95)/0.05, 2) * 0.005; x *= scaleFactor; y *= scaleFactor; }
        posBack.setZ(i, -z); posBack.setX(i, x); posBack.setY(i, y);
    }
    backGeo.computeVertexNormals();
    parts.backShell = new THREE.Mesh(backGeo, matTranslucentBody); backGroup.add(parts.backShell);

    parts.backSkel = new THREE.Group();
    const spineCurvePoints = [];
    for(let i=0; i<=10; i++) {
        const t = i/10, z = -t * CONFIG.backLength, y = Math.exp(-Math.pow((t-0.15)*5,2))*0.15 + Math.exp(-Math.pow((t-0.85)*8,2))*0.1;
        spineCurvePoints.push(new THREE.Vector3(0, y, z));
    }
    const spineCurve = new THREE.CatmullRomCurve3(spineCurvePoints);
    // ä½¿ç”¨ç‹¬ç«‹çš„ matSkeleton
    parts.backSkel.add(new THREE.Mesh(new THREE.TubeGeometry(spineCurve, 20, 0.2, 8, false), matSkeleton));
    for(let i=1; i<9; i++) {
        const rib = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.width*0.7, 0.1, 0.2), matSkeleton); rib.position.copy(spineCurve.getPoint(i/10)); parts.backSkel.add(rib);
    }
    backGroup.add(parts.backSkel);

    const projGroup = new THREE.Group(); projGroup.position.z = -CONFIG.backLength + 0.15; backGroup.add(projGroup);
    const projShellGroup = new THREE.Group();
    const projGeo = new THREE.ExtrudeGeometry(baseShape, { depth: CONFIG.projLength, steps: 1, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 3 });
    const posProj = projGeo.attributes.position; for(let i=0; i<posProj.count; i++) posProj.setZ(i, -posProj.getZ(i));
    projGeo.computeVertexNormals();
    const projShellMesh = new THREE.Mesh(projGeo, matTranslucentProj); projShellGroup.add(projShellMesh);

    const detailsGroup = new THREE.Group(); detailsGroup.position.z = -CONFIG.projLength / 2;
    detailsGroup.add(new THREE.Mesh(new THREE.CircleGeometry(0.8, 32).rotateX(-Math.PI/2), matLensSimple).translateY(CONFIG.thickness/2+0.15));
    
    // æ–œå››æ£±é”¥å…‰æŸ
    const beamGeo = new THREE.CylinderGeometry(4, 0.5, 12, 4, 1, true); beamGeo.rotateY(Math.PI/4); beamGeo.translate(0, 6, 0); 
    const posBeam = beamGeo.attributes.position; for(let i=0; i<posBeam.count; i++) posBeam.setZ(i, posBeam.getZ(i) + posBeam.getY(i) * 0.25); beamGeo.computeVertexNormals();
    const beamMat = new THREE.MeshBasicMaterial({ color: 0x4db8ff, transparent: true, opacity: 0.08, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending });
    parts.beam = new THREE.Mesh(beamGeo, beamMat); parts.beam.position.y = 0.2; detailsGroup.children[0].add(parts.beam); 

    // ã€ä¿®æ”¹ã€‘æ•£çƒ­å­”å®ä½“åŒ– (BoxGeometry)ï¼Œç§»é™¤æ—‹è½¬ï¼Œç¡®ä¿æœ‰åšåº¦ä¸”å¯è§
    const ventGeo = new THREE.BoxGeometry(2.2, 0.05, 1.2);
    
    // ã€å…³é”®ä¿®å¤ã€‘æŠ¬é«˜æ•£çƒ­å­”ä½ç½®
    // å¤–å£³åšåº¦çš„ä¸€åŠæ˜¯ 1.0 (CONFIG.thickness/2)
    // Bevel (å€’è§’) ä¼šè®©å¤–å£³è¡¨é¢å‘å¤–è†¨èƒ€ 0.1
    // æ‰€ä»¥å¤–å£³çš„å®é™…è¡¨é¢åœ¨ Y = 1.1 å·¦å³
    // æˆ‘ä»¬è®¾ç½®åˆ° 1.135 (1.1 + åŠé«˜0.025 + 0.01é˜²å†²çªä½™é‡)ï¼Œç¡®ä¿å®ƒæµ®åœ¨è¡¨é¢ä¸Š
    const ventY = CONFIG.thickness/2 + 0.1 + 0.025 + 0.01;

    const ventL = new THREE.Mesh(ventGeo, matVent); 
    ventL.position.set(-2.4, ventY, 0);
    
    const ventR = new THREE.Mesh(ventGeo, matVent); 
    ventR.position.set(2.4, ventY, 0);
    
    detailsGroup.add(ventL, ventR);

    projShellGroup.add(detailsGroup); parts.projShell = projShellGroup; projGroup.add(parts.projShell);

    // å†…æ„
    parts.projInternal = new THREE.Group(); parts.projInternal.position.z = -CONFIG.projLength / 2; projGroup.add(parts.projInternal);
    const opticalEngine = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 2), matInternal);
    const internalLens = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.6, 32), matLensSimple); internalLens.position.set(0, 0.85, 0); opticalEngine.add(internalLens); 
    parts.projInternal.add(opticalEngine);
    const pcb = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 2.5), matPCB); pcb.position.y = -0.65; parts.projInternal.add(pcb);
    const fanGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.2, 16);
    const fanL = new THREE.Mesh(fanGeo, matFan); fanL.rotation.z = Math.PI/2; fanL.position.set(-1.6, 0, 0);
    const fanR = new THREE.Mesh(fanGeo, matFan); fanR.rotation.z = Math.PI/2; fanR.position.set(1.6, 0, 0);
    parts.fans.push(fanL, fanR); parts.projInternal.add(fanL, fanR);
    
    // ã€æ›´æ–°ã€‘éš”çƒ­èˆ±
    const chamberGeo = new THREE.BoxGeometry(3.6, 1.7, 2.5);
    parts.chamberL = new THREE.Mesh(chamberGeo, matChamber); parts.chamberL.position.set(-1.8, 0.15, 0); 
    parts.chamberR = new THREE.Mesh(chamberGeo, matChamber); parts.chamberR.position.set(1.8, 0.15, 0); 
    
    // ã€æ–°å¢ã€‘å†…éƒ¨éš”çƒ­èˆ±ä¸Šçš„å®ä½“æ•£çƒ­å­”
    // å°ºå¯¸é€»è¾‘ï¼šå¤–å£³æ•£çƒ­å­”æ˜¯ 2.2x1.2ï¼Œä½ç½®åœ¨ +/- 2.4
    // å†…éƒ¨éš”çƒ­èˆ±ä½äº +/- 1.8ï¼Œå¦‚æœæˆ‘ä»¬è¦è®©æ•£çƒ­å­”â€œå¯¹åº”â€ï¼Œå®ƒä»¬çš„ç›¸å¯¹ä½ç½®è¦ä¸€è‡´
    // éš”çƒ­èˆ±çš„é¡¶éƒ¨æ˜¯ y = 1.7 / 2 = 0.85
    // æˆ‘ä»¬æ”¾ä¸€ä¸ªç¨å¾®å°ä¸€ç‚¹çš„é»‘è‰²è–„ç‰‡/ç›’å­åœ¨é¡¶éƒ¨
    const innerVentSolidGeo = new THREE.BoxGeometry(1.8, 0.05, 1.0); // ç¨å¾®æ¯”å¤–éƒ¨çš„å°ä¸€ç‚¹
    const innerVentY = 0.85 + 0.025 + 0.01; // é¡¶é¢ + åŠé«˜ + æµ®èµ·
    
    // å·¦ä¾§å†…éƒ¨æ•£çƒ­å­” (ç›¸å¯¹äº chamberL çš„å±€éƒ¨åæ ‡)
    // ChamberL åœ¨ -1.8ã€‚å¤–éƒ¨ VentL åœ¨ -2.4ã€‚å·®å€¼æ˜¯ -0.6ã€‚
    const ivL = new THREE.Mesh(innerVentSolidGeo, matVent);
    ivL.position.set(-0.6, innerVentY, 0);
    parts.chamberL.add(ivL);

    // å³ä¾§å†…éƒ¨æ•£çƒ­å­” (ç›¸å¯¹äº chamberR çš„å±€éƒ¨åæ ‡)
    // ChamberR åœ¨ 1.8ã€‚å¤–éƒ¨ VentR åœ¨ 2.4ã€‚å·®å€¼æ˜¯ +0.6ã€‚
    const ivR = new THREE.Mesh(innerVentSolidGeo, matVent);
    ivR.position.set(0.6, innerVentY, 0);
    parts.chamberR.add(ivR);

    parts.projInternal.add(parts.chamberL, parts.chamberR);

    // ==========================================
    // 4. è¾…åŠ©å¼•å¯¼çº¿
    // ==========================================
    parts.l1 = createGuideline(new THREE.Vector3(0,0,2.5), new THREE.Vector3(0,0,2.5)); parts.lines.add(parts.l1);
    parts.l2 = createGuideline(new THREE.Vector3(0,0,-5), new THREE.Vector3(0,0,-5)); parts.lines.add(parts.l2);
    parts.l3 = createGuideline(new THREE.Vector3(0,0,-12), new THREE.Vector3(0,0,-12)); parts.lines.add(parts.l3);

    // ==========================================
    // 5. ç¯å¢ƒå…‰ç…§ (ã€ä¿®æ”¹ã€‘å¢å¼ºäº®åº¦)
    // ==========================================
    const al = new THREE.AmbientLight(0xffffff, 0.8); scene.add(al);
    // ã€æ–°å¢ã€‘åŠçƒå…‰ï¼Œæ¨¡æ‹Ÿè‡ªç„¶å…‰ç…§ï¼Œæ¶ˆé™¤æ­»é»‘
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); scene.add(hemiLight);
    
    const dl = new THREE.DirectionalLight(0xffffff, 1.2); dl.position.set(10,20,5); dl.castShadow=true; scene.add(dl);
    const pl = new THREE.PointLight(0x4db8ff, 0.6); pl.position.set(0,-5,0); scene.add(pl);
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.ShadowMaterial({opacity:0.05}));
    plane.rotation.x = -Math.PI/2; plane.position.y = -10; root.add(plane);

    // ==========================================
    // 6. äº¤äº’é€»è¾‘ (Tooltip & Highlight)
    // ==========================================
    const canvas = document.getElementById('angle-picker'); 
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('angle-value');
    const cx = canvas.width/2, cy = canvas.height/2, clockRadius = canvas.width*0.35;
    let handAngle = -Math.PI; let isDragging = false;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const tooltip = document.getElementById('tooltip');

    const layers = [
        {
            id: 'L3',
            name: 'Top Layer',
            desc: '<strong>å…‰æœºæ¨¡å—</strong>1080PæŠ•å½±+é™éŸ³æ•£çƒ­é£æ‰‡<br>æ•£çƒ­å­”+éš”çƒ­èˆ±',
            objects: [parts.projInternal] 
        },
        {
            id: 'L2',
            name: '2nd Layer',
            desc: '<strong>æŠ•å½±æ¨¡å—</strong>ç£¨ç ‚å¡‘æ–™æŠ•å½±æ¨¡å—å¤–å£³',
            objects: [parts.projShell]
        },
        {
            id: 'L1',
            name: '1st Layer',
            desc: '<strong>é¾™éª¨</strong>å¤åˆå¡‘æ–™æè´¨éª¨æ¶',
            objects: [parts.seatSkel, parts.backSkel, parts.hingeInternal, parts.hinge]
        },
        {
            id: 'L0',
            name: 'Bottom Layer',
            desc: '<strong>é å«+åå«</strong>è®°å¿†æ£‰ï¼Œå†…å±‚é«˜æ”¯æ’‘ï¼Œå¤–å±‚é›¶å‹æ„Ÿ',
            objects: [parts.seatShell, parts.backShell]
        }
    ];

    let hoveredLayer = null;

    function drawClock() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.beginPath(); ctx.arc(cx,cy,clockRadius+20,0,Math.PI*2); ctx.fillStyle='#f9f9f9'; ctx.fill(); ctx.strokeStyle='#eee'; ctx.stroke();
        ctx.beginPath(); ctx.arc(cx,cy,clockRadius,-Math.PI,-Math.PI/2); ctx.strokeStyle='rgba(33,150,243,0.2)'; ctx.lineWidth=15; ctx.stroke();
        ctx.beginPath(); ctx.arc(cx,cy,8,0,Math.PI*2); ctx.fillStyle='#333'; ctx.fill();
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+clockRadius*0.6,cy); ctx.strokeStyle='#333'; ctx.lineWidth=8; ctx.lineCap='round'; ctx.stroke();
        ctx.font="12px Arial"; ctx.fillStyle="#666"; ctx.fillText("åå«",cx+clockRadius*0.7,cy+4);
        const hx=cx+Math.cos(handAngle)*clockRadius*0.9, hy=cy+Math.sin(handAngle)*clockRadius*0.9;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(hx,hy); ctx.strokeStyle='#E91E63'; ctx.lineWidth=8; ctx.lineCap='round'; ctx.stroke();
        ctx.beginPath(); ctx.arc(hx,hy,12,0,Math.PI*2); ctx.fillStyle='#E91E63'; ctx.fill(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(hx,hy,4,0,Math.PI*2); ctx.fill();
        const deg=Math.abs(Math.round(THREE.MathUtils.radToDeg(handAngle)));
        statusDiv.innerText = Math.abs(deg-180)<5?"èººå§¿ (180Â°)":Math.abs(deg-90)<5?"åå§¿ (90Â°)":`è§’åº¦ ${deg}Â°`;
    }

    function updateAngle(x,y) {
        if(STATE.mode === 'exploded') return; 
        const rect = canvas.getBoundingClientRect();
        let angle = Math.atan2(y-rect.top-cy, x-rect.left-cx);
        if(angle>0) angle=-Math.PI; if(angle>-Math.PI/2) angle=-Math.PI/2;
        handAngle = angle; backGroup.rotation.x = handAngle + Math.PI; drawClock();
    }

    // ã€å…³é”®ä¿®å¤ã€‘é«˜äº®å‡½æ•°ï¼šç›´æ¥æ“ä½œ emissiveï¼Œä¸ä¾èµ– userData ç¼“å­˜åŸå§‹çŠ¶æ€ï¼Œé¿å…æ··ä¹±
    function highlightLayer(layer) {
        layer.objects.forEach(rootObj => {
            rootObj.traverse(child => {
                if (child.isMesh && child.material) {
                    // ç¡®ä¿æ˜¯æ”¯æŒ emissive çš„æè´¨
                    if (child.material.emissive) {
                        child.material.emissive.setHex(0x444444); // äº®ç°è‰²é«˜äº®
                    }
                }
            });
        });
    }

    // ã€å…³é”®ä¿®å¤ã€‘æ¸…ç©ºé«˜äº®ï¼šå¼ºåˆ¶å¤ä½åˆ°é»‘è‰²
    function clearHighlight() {
        if (!hoveredLayer) return;
        hoveredLayer.objects.forEach(rootObj => {
            rootObj.traverse(child => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(0x000000); // æ¢å¤ä¸å‘å…‰
                }
            });
        });
    }

    function onMouseMove(event) {
        if(isDragging) updateAngle(event.clientX, event.clientY);

        if (STATE.mode === 'exploded') {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // æ”¶é›†æ‰€æœ‰äº¤äº’å¯¹è±¡
            let allInteractables = [];
            layers.forEach(l => l.objects.forEach(o => o.traverse(c => { if(c.isMesh) allInteractables.push(c) })));

            const intersects = raycaster.intersectObjects(allInteractables);

            if (intersects.length > 0) {
                let hitObj = intersects[0].object;
                let foundLayer = null;

                // åå‘æŸ¥æ‰¾æ‰€å±å±‚çº§
                for (let layer of layers) {
                    for (let rootObj of layer.objects) {
                        // æ£€æŸ¥ hitObj æ˜¯å¦æ˜¯ rootObj çš„åä»£
                        let parent = hitObj;
                        while(parent) {
                            if(parent === rootObj) { foundLayer = layer; break; }
                            parent = parent.parent;
                        }
                        if(foundLayer) break;
                    }
                    if(foundLayer) break;
                }

                if (foundLayer) {
                    if (hoveredLayer !== foundLayer) {
                        clearHighlight(); // å…ˆæ¸…é™¤æ—§çš„
                        hoveredLayer = foundLayer;
                        highlightLayer(hoveredLayer); // å†äº®æ–°çš„
                    }
                    tooltip.innerHTML = foundLayer.desc;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (event.clientX + 15) + 'px';
                    tooltip.style.top = (event.clientY + 15) + 'px';
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if (hoveredLayer) {
                    clearHighlight();
                    hoveredLayer = null;
                    tooltip.style.display = 'none';
                    document.body.style.cursor = 'move';
                }
            }
        } else {
            tooltip.style.display = 'none';
            if (!isDragging) document.body.style.cursor = 'move';
        }
    }

    const STATE = {
        mode: 'xray', 
        originalPositions: {
            seatSkel: parts.seatSkel.position.clone(), backSkel: parts.backSkel.position.clone(),
            projShell: parts.projShell.position.clone(), projInternal: parts.projInternal.position.clone(),
            chamberL: parts.chamberL.position.clone(), chamberR: parts.chamberR.position.clone(),
            hingeInt: parts.hingeInternal.position.clone()
        }
    };

    window.setMode = function(mode) {
        const previousMode = STATE.mode; STATE.mode = mode;
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        const btnIdx = mode === 'xray' ? 0 : mode === 'solid' ? 1 : 2;
        document.querySelectorAll('.mode-btn')[btnIdx].classList.add('active');
        document.getElementById('clock-container').style.opacity = (mode === 'exploded') ? '0.3' : '1';
        document.getElementById('clock-container').style.pointerEvents = (mode === 'exploded') ? 'none' : 'auto';

        const useSolid = (mode === 'solid');
        parts.seatShell.material = useSolid ? matSolidBody : matTranslucentBody;
        parts.backShell.material = useSolid ? matSolidBody : matTranslucentBody;
        parts.projShell.children[0].material = useSolid ? matSolidProj : matTranslucentProj;
        
        const showInternal = (mode === 'xray' || mode === 'exploded');
        if (parts.beam) parts.beam.visible = (mode !== 'exploded');

        if (previousMode === 'exploded' && mode === 'solid') {
            parts.seatSkel.visible = true; parts.backSkel.visible = true; parts.projInternal.visible = true; parts.hingeInternal.visible = true;
            setTimeout(() => {
                if (STATE.mode === 'solid') {
                    parts.seatSkel.visible = false; parts.backSkel.visible = false; parts.projInternal.visible = false; parts.hingeInternal.visible = false;
                }
            }, 800);
        } else {
            parts.seatSkel.visible = showInternal; parts.backSkel.visible = showInternal; parts.projInternal.visible = showInternal; parts.hingeInternal.visible = showInternal;
        }
        parts.lines.visible = (mode === 'exploded');

        if (mode === 'exploded') {
            new TWEEN.Tween(backGroup.rotation).to({ x: 0 }, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
            new TWEEN.Tween(parts.seatShell.position).to({ y: -5.0 }, 1000).start(); new TWEEN.Tween(parts.backShell.position).to({ y: -5.0 }, 1000).start();
            new TWEEN.Tween(parts.seatSkel.position).to({ y: 0.0 }, 1000).start(); new TWEEN.Tween(parts.backSkel.position).to({ y: 0.0 }, 1000).start();
            new TWEEN.Tween(parts.hingeInternal.position).to({ y: 0.0 }, 1000).start(); new TWEEN.Tween(parts.hinge.position).to({ y: 0.0 }, 1000).start();
            new TWEEN.Tween(parts.projShell.position).to({ y: 5.0 }, 1000).start();
            new TWEEN.Tween(parts.projInternal.position).to({ y: 10.0 }, 1000).start();
            new TWEEN.Tween(parts.chamberL.position).to({ x: -3.5 }, 1000).start(); new TWEEN.Tween(parts.chamberR.position).to({ x: 3.5 }, 1000).start();
        } else {
            new TWEEN.Tween(parts.seatShell.position).to({ y: 0 }, 800).start(); new TWEEN.Tween(parts.backShell.position).to({ y: 0 }, 800).start();
            new TWEEN.Tween(parts.seatSkel.position).to(STATE.originalPositions.seatSkel, 800).start(); new TWEEN.Tween(parts.backSkel.position).to(STATE.originalPositions.backSkel, 800).start();
            new TWEEN.Tween(parts.hingeInternal.position).to(STATE.originalPositions.hingeInt, 800).start(); new TWEEN.Tween(parts.hinge.position).to({ y: 0 }, 800).start();
            new TWEEN.Tween(parts.projShell.position).to(STATE.originalPositions.projShell, 800).start();
            new TWEEN.Tween(parts.projInternal.position).to(STATE.originalPositions.projInternal, 800).start();
            new TWEEN.Tween(parts.chamberL.position).to(STATE.originalPositions.chamberL, 800).start(); new TWEEN.Tween(parts.chamberR.position).to(STATE.originalPositions.chamberR, 800).start();
        }
    }

    window.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mousedown', (e)=>{isDragging=true; updateAngle(e.clientX,e.clientY)});
    window.addEventListener('mouseup', ()=>{isDragging=false});
    canvas.addEventListener('touchstart', (e)=>{e.preventDefault(); isDragging=true; updateAngle(e.touches[0].clientX,e.touches[0].clientY);}, {passive:false});
    window.addEventListener('touchmove', (e)=>{if(isDragging) {e.preventDefault(); updateAngle(e.touches[0].clientX,e.touches[0].clientY);}}, {passive:false});
    window.addEventListener('touchend', ()=>{isDragging=false});
    
    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        orbitControls.update();
        renderer.render(scene, camera);
        
        if (parts.beam && parts.beam.visible) {
            parts.beam.material.opacity = 0.08 + Math.sin(Date.now() * 0.003) * 0.02;
        }

        if(STATE.mode === 'exploded') {
            const p1 = new THREE.Vector3(); parts.seatShell.getWorldPosition(p1);
            const p2 = new THREE.Vector3(); parts.seatSkel.getWorldPosition(p2);
            parts.l1.geometry.setFromPoints([p1, p2]); parts.l1.computeLineDistances(); parts.l1.visible=true;

            const p3 = new THREE.Vector3(); parts.backShell.getWorldPosition(p3);
            const p4 = new THREE.Vector3(); parts.backSkel.children[0].getWorldPosition(p4);
            parts.l2.geometry.setFromPoints([p3, p4]); parts.l2.computeLineDistances(); parts.l2.visible=true;
            
            // å¼•å¯¼çº¿ l3ï¼šè¿æ¥å¤–éƒ¨é•œå¤´ (Level 2) å’Œ å†…éƒ¨é•œå¤´ (Level 3)
            const p5 = new THREE.Vector3(); 
            // External Lens: projShell -> detailsGroup(children[1]) -> lens(children[0])
            parts.projShell.children[1].children[0].getWorldPosition(p5);
            
            const p6 = new THREE.Vector3(); 
            // Internal Lens: projInternal -> opticalEngine(children[0]) -> internalLens(children[0])
            parts.projInternal.children[0].children[0].getWorldPosition(p6);
            
            parts.l3.geometry.setFromPoints([p5, p6]); parts.l3.computeLineDistances(); parts.l3.visible=true;
        } else {
            parts.lines.visible = false;
        }
    }
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    
    drawClock();
    animate();
</script>
</body>
</html>
